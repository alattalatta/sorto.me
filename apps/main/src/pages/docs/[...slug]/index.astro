---
import type { CompatData, Identifier } from '@mdn/browser-compat-data'
import bcd from '@mdn/browser-compat-data' with { type: 'json' }
import type { GetStaticPaths } from 'astro'
import { getCollection } from 'astro:content'
import ContentGrid from 'components/ContentGrid'
import Doc from 'components/Doc.astro'
import Footer from 'components/Footer.astro'
import MainNav from 'components/MainNav.astro'
import RelatedDocs from 'components/RelatedDocs.astro'
import TableOfContents from 'components/TableOfContents.astro'
import { escapeUTF8 } from 'entities'
import Shell from 'layouts/Shell.astro'
import type { Root } from 'mdast'
import { remark } from 'remark'
import stripMarkdown from 'strip-markdown'
import { select } from 'unist-util-select'

export const getStaticPaths = (async () => {
  return (await getCollection('docs')).map((entry) => ({
    params: { slug: entry.id.replace('.mdx', '') },
    props: entry,
  }))
}) satisfies GetStaticPaths

const props = Astro.props
const path = props.id.replace('.mdx', '')
const site = Astro.site?.toString() ?? ''

const {
  Content,
  headings,
  remarkPluginFrontmatter: { lastModified },
} = await props.render()

const firstParagraphProcessor = remark()
  .use(() => (root: Root) => select('paragraph', root) || root.children[0] || root)
  .use(stripMarkdown)

const description =
  props.data.description ??
  (await firstParagraphProcessor.process(props.body as string).then((res) => String(res).trim().replace(/\\/g, '')))

const bcdData = (() => {
  if (!props.data.bcd) {
    return null
  }

  const [category, ...identifiers] = props.data.bcd.split('.')
  const data = identifiers.reduce<Identifier | null>(
    (prv, cur) => {
      if (!prv) {
        return null
      }

      return prv[cur]
    },
    bcd[category as Exclude<keyof CompatData, '__meta' | 'browsers'>]
  )

  if (data) {
    return {
      data,
      key: identifiers.at(-1)!,
    }
  }
  return null
})()

const parentPath = path.split('/').slice(0, -1).join('/')
const siblingRegex = new RegExp(`^${parentPath}/[^/]+$`, 'i')

const allDocs = await getCollection('docs')

const parentDocData = allDocs.find((entry) => entry.id === `${parentPath}.mdx`)

const parentDoc = parentDocData ? ([parentPath, parentDocData.data.title] as const) : null
const siblingDocs = allDocs
  .filter((entry) => siblingRegex.test(entry.slug))
  .sort((a, b) => a.id.localeCompare(b.id))
  .map((entry) => {
    const id = entry.id.replace('.mdx', '')
    return [id, entry.data.titleShort ?? entry.data.title] as readonly [id: string, title: string]
  })
---

<Shell
  canonicalPath={`docs/${path}`}
  description={description}
  image={`${site}docs/${path}/og.png`}
  title={props.data.title}
>
  <Fragment slot="head">
    <meta content="article" property="og:type" />
    <meta content="alattalatta" property="article:author" />
    <meta content={lastModified} property="article:modified_time" />
  </Fragment>
  <h1 class="no-screen">{props.data.title}</h1>
  <ContentGrid client:load>
    <MainNav
      links={[
        ['blog', [['(...more)', '/posts']]],
        [
          'docs',
          [
            ['HTML', '/docs/Web/HTML'],
            ['CSS', '/docs/Web/CSS'],
          ],
        ],
      ]}
      slot="header"
    >
      <TableOfContents {headings} slot="toc" />
      {
        (siblingDocs.length > 0 || parentDoc !== null) && (
          <RelatedDocs docs={siblingDocs} idNow={props.id.replace('.mdx', '')} parent={parentDoc} />
        )
      }
    </MainNav>
    <main>
      <Doc bcd={bcdData} content={Content} post={props} />
    </main>
    <Footer {lastModified} slot="footer" />
  </ContentGrid>
</Shell>
