---
import type { CompatData, Identifier } from '@mdn/browser-compat-data'
import bcd from '@mdn/browser-compat-data' with { type: 'json' }
import type { GetStaticPaths } from 'astro'
import { getCollection } from 'astro:content'
import ContentGrid from 'components/ContentGrid'
import Doc from 'components/Doc.astro'
import Footer from 'components/Footer.astro'
import MainNav from 'components/MainNav.astro'
import RelatedDocs from 'components/RelatedDocs.astro'
import TableOfContents from 'components/TableOfContents.astro'
import DocShell from 'layouts/DocShell.astro'
import type { Root } from 'mdast'
import { remark } from 'remark'
import stripMarkdown from 'strip-markdown'
import { select } from 'unist-util-select'

export const getStaticPaths = (async () => {
  return (await getCollection('docs')).map((entry) => ({
    params: { slug: entry.id.replace('.mdx', '') },
    props: entry,
  }))
}) satisfies GetStaticPaths

const props = Astro.props
const path = props.id.replace('.mdx', '')
const site = Astro.site?.toString() ?? ''

const {
  Content,
  headings,
  remarkPluginFrontmatter: { lastModified },
} = await props.render()

const firstParagraphProcessor = remark()
  .use(() => (root: Root) => select('paragraph', root) || root.children[0] || root)
  .use(stripMarkdown)

const description =
  props.data.description ??
  (await firstParagraphProcessor.process(props.body as string).then((res) => String(res).trim().replace(/\\/g, ''))) ??
  ''

const bcdData = (() => {
  if (!props.data.bcd) {
    return null
  }

  const [category, ...identifiers] = props.data.bcd.split('.')
  const data = identifiers.reduce<Identifier | null>(
    (prv, cur) => {
      if (!prv) {
        return null
      }

      return prv[cur]
    },
    bcd[category as Exclude<keyof CompatData, '__meta' | 'browsers'>]
  )

  if (data) {
    return {
      data,
      key: identifiers.at(-1)!,
    }
  }
  return null
})()

const pathComponents = path.split('/')
const techRootPath = pathComponents.slice(0, 2).join('/')
const parentPath = pathComponents.slice(0, -1).join('/')
const siblingRegex = new RegExp(`^${parentPath}/[^/]+$`, 'i')

const allDocs = await getCollection('docs')

const techRootDocData = pathComponents.length > 3 ? allDocs.find((entry) => entry.id === `${techRootPath}.mdx`) : null
const parentDocData = allDocs.find((entry) => entry.id === `${parentPath}.mdx`)

const techRootDoc = techRootDocData ? ([techRootPath, techRootDocData.data.title] as const) : null
const parentDoc = parentDocData ? ([parentPath, parentDocData.data.title] as const) : null
const siblingDocs = allDocs
  .filter((entry) => siblingRegex.test(entry.slug))
  .sort((a, b) => a.id.localeCompare(b.id))
  .map((entry) => {
    const id = entry.id.replace('.mdx', '')
    return [id, entry.data.titleShort ?? entry.data.title] as readonly [id: string, title: string]
  })
---

<DocShell
  canonicalPath={`docs/${path}`}
  description={description}
  image={`${site}docs/${path}/og.png`}
  title={props.data.title}
>
  <Fragment slot="head">
    <meta content="article" property="og:type" />
    <meta content="alattalatta" property="article:author" />
    <meta content={lastModified} property="article:modified_time" />
  </Fragment>
  <ContentGrid client:load>
    <MainNav
      links={[
        ['blog', [], '/posts'],
        ['docs', [], '/docs'],
      ]}
      slot="header"
    >
      <TableOfContents {headings} slot="toc" />
      {
        (siblingDocs.length > 0 || parentDoc !== null) && (
          <RelatedDocs docs={siblingDocs} idNow={props.id.replace('.mdx', '')} parent={parentDoc} root={techRootDoc} />
        )
      }
    </MainNav>
    <main>
      <Doc
        bcd={bcdData}
        content={Content}
        {description}
        pinnable={props.data.pinnable}
        slug={props.slug}
        title={props.data.title}
      />
    </main>
    <Footer {lastModified} slot="footer" />
  </ContentGrid>
</DocShell>
