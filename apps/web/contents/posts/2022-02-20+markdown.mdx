---
title: Markdown이 약간 부족할 때
description: 내게 필요한 Markdown 컴파일러 만들기
image: /gen/2022-02-20/image.png
---

일상적인 글에서는 [CommonMark](https://commonmark.org/)도 충분한 기능을 제공한다. 하지만 난 Markdown 문서에 [`<dl>`](/docs/Web/HTML/Element/dl)과 _노트 박스_(클래스를 지정한 [`<div>`](/docs/Web/HTML/Element/div))를 **가벼운 구문으로** 넣을 방법이 필요했다. Markdown에도 HTML 태그를 직접 삽입할 수 있는 환경이지만, 글을 쓰는데 마크업을 작성하고 싶지 않아서 굳이 컴파일링을 거치는 것이니까 여닫으면서 들여쓰기까지 해야 하는 태그는 어떻게든 피하고 싶었다.

<SideBySide caption="Markdown / HTML 코드의 비교">
  
```markdown
- : JavaScript
  - 가벼운 인터프리터 혹은 *just-in-time* 컴파일
    프로그래밍 언어로, 일급 함수를 지원합니다.

> [note]
> JavaScript는 웹 페이지를 위한 스크립트 언어로 잘
> 알려져 있지만, [Node.js](https://nodejs.org/)처럼
> 비 브라우저 환경에서도 사용하고 있습니다.

````
```html
<dl>
  <dt>JavaScript</dt>
  <dd>
    가벼운 인터프리터 혹은 <i>just-in-time</i>
    컴파일 프로그래밍 언어로, 일급 함수를 지원합니다.
  </dd>
</dl>

<div class="notebox notebox-note">
  <p>
    JavaScript는 웹 페이지를 위한 스크립트 언어로 잘 알려져 있지만, <a href="https://nodejs.org/">Node.js</a>처럼 비
    브라우저 환경에서도 사용하고 있습니다.
  </p>
</div>
````

</SideBySide>

하지만 완전히 새로운 Markdown 구문을 만들기엔 파싱하기도 너무 어렵고, 힘들게 구현해봤자 에디터와 포매팅 지원이 제대로 되지 않아 제대로 만족할 수도 없을 테니, 기존 구문을 특정한 형식에 맞춰 입력하면 내가 원하는 HTML 코드가 나오도록 하고 싶었다. 예컨대 블록 인용문의 콘텐츠를 `[note]`, `[warn]`, `[fatal]`이라는 특정 문자열로 시작하면, 그 키워드에 맞는 색을 적용한 노트 박스로 렌더링하는.

당시에도, 그리고 지금도 순수한 Markdown 문서가 아니라 [MDX](https://mdxjs.com/)를 쓰고 있는데, 이 마음을 먹은 당시엔 MDX 컴파일러가 Markdown 구문을 [remark](https://github.com/remarkjs/remark)와 [rehype](https://github.com/rehypejs/rehype)로 변환한다는 것 이상은 알 수 없었다. 덕분에 구현 방향조차 잡지 못했고, 특히 관련 패키지들이 작은 단위로 여러 곳에 나눠져있어서 README를 읽는 것으로는 시작해야 할 곳이 감조차 잡히지 않았다. React 컴포넌트를 넣을 수밖에.

```md
# 헤딩

<Notebox type="note">블록 인용문 구문에 비하면 너무 귀찮다는 점을 참고하세요.</Notebox>

등등...
```

이것도 그다지 가벼운 작성법은 아닌 데다가 `<dl>`, `<dt>`, `<dd>`는 결국 직접 입력해야 했기에, 사이트 코드 전체 개편과 함께 Markdown이 어디서 어떻게 처리되는지 제대로 알아보려고 했다.

# AST

세상 모든 기능이 npm에 패키지로 존재한다고 하듯, Markdown을 HTML로 변환해주는 컴파일러도 당연히 존재한다. [markdown-it](https://www.npmjs.com/package/markdown-it)이 대표적인가보다. 그러나 ― 사실 MDX를 쓰려면 선택지가 없었던 것에 가깝지만 ― 나는 remark를 바탕으로 컴파일러를 구성했다. remark 컴파일러는 파싱 후 바로 HTML로 컴파일하는 것이 아니라, <abbr title="Abstract Syntax Tree">AST</abbr>를 출력하는 것이 특징이자 장점이다.

AST는 콘텐츠의 구문 구조를 추상적으로 나타낸 트리다. *추상적*인 이유는 콘텐츠의 실제 형태와 상관없이 구문에서 의미를 갖고 있는 부분만 포함하기 때문이다. 예컨대 JavaScript는 들여쓰기와 같은 공백 문자에 민감하지 않으므로, 스페이스와 탭 등은 트리에 포함되지 않는다. 덕분에 AST로 표현된 콘텐츠를 읽을 땐 코드 스타일과 같은 세부 사항에 신경 쓰지 않고 내용에만 집중할 수 있다.

파일을 AST로 읽어서 서식은 다 날려버리고, 자체 규칙으로 다시 서식해 출력하는 [Prettier](https://prettier.io/)가 대표적인 AST 활용 예시다.

<SideBySide caption="같은 AST로 표현할 수 있는, 서로 다른 두 코드">
  
```js
function echo(x) {
  if (x) console.log(x);
}
```

```js
function echo(x) {
  if (x) {
    console.log(x)
  }
}
```

</SideBySide>

# Markdown 변환 과정

## unist와 unified

AST는 개념인 만큼 따로 정해진 구조는 없다. 그러나 트리 구조라는 것은 변함이 없으므로, 표현하는 내용의 종류가 달라도 세부 구현이 같으면 동일한 작업을 할 수 있다. 즉, 어떤 트리가 Markdown, HTML, JavaScript 등등 그 어떤 것을 나타내더라도 세부 구조가 같으면 비교나 순회처럼 기본적인 기능은 공통으로 사용할 수 있다. 이를 위해 AST의 기본적인 명세를 커뮤니티에서 정의한 것이 [unist](https://github.com/syntax-tree/unist)다.

unist는 기본적으론 `Node` 인터페이스의 `type` 속성으로 노드가 어떤 노드인지 나타낸다. 자식을 가질 수 있는 노드(`Parent` 인터페이스)는 `children` 속성에 노드 배열을, 자식을 가질 수 없는 노드(`Literal` 인터페이스)는 `value` 속성에 자신의 값을 포함한다. TypeScript를 접해본 적이 있으면 [unist 인터페이스 명세](https://github.com/syntax-tree/unist#nodes)를 이해하는 것은 어렵지 않다.

그리고 [unified](https://github.com/unifiedjs/unified)는 unist 트리에 대한 *프로세서*다. 프로세서는 먼저 소스를 파싱해 unist AST를 생성하고, 트랜스포머로 트리를 순회하면서 조작한 후, 컴파일러로 결과를 출력한다.

![파서를 지나 트랜스포머를 거쳐 컴파일러로](/gen/2022-02-20/pipeline.png)

unist와 마찬가지로 unified 스스로는 파싱할 코드의 종류와, 컴파일할 결과의 형태를 정의하지 않고, 입력 값을 처리할 수 있는 파이프라인을 정의할 뿐이다. 파서, 트랜스포머, 컴파일러는 프로세서에 *플러그인*으로 추가하게 된다.

## 파서와 컴파일러와 트랜스포머

나는 Markdown 코드를 AST로 바꿔야 하므로 Markdown *파서*가 필요하다. Markdown 지원은 [remark](https://github.com/remarkjs/remark)의 영역으로, `remark-parse`가 파서 플러그인, `remark-stringify`가 컴파일러 플러그인이다. 내 목표는 Markdown 파일을 HTML로 변환해 웹 페이지에 출력하는 것이기 때문에 `remark-stringify`는 필요하지 않고, `remark-parse`만 사용한다.

그다음엔 AST를 HTML 코드로 *컴파일*해야 하며, unified의 HTML 지원은 [rehype](https://github.com/rehypejs/rehype)가 한다. remark와 마찬가지로 `rehype-parse`가 파서, `rehype-stringify`가 컴파일러다. 그리고 HTML 소스 코드를 읽을 일은 없으므로 `rehype-stringify`만 사용하면 된다.

하지만 `remark-parse`와 `rehype-stringify`는 호환되지 않는다. 모두 unified 생태계의 일원이지만, 전자는 unist 명세를 Markdown에 맞게 확장한 [mdast](https://github.com/syntax-tree/mdast) 트리를 생성하고, 후자는 HTML 전용으로 확장한 [hast](https://github.com/syntax-tree/hast) 트리를 기대하기 때문. 예컨대 mdast에서는 리스트를 `{ type: 'list', ordered: boolean }` 노드로 표현하지만 hast에서는 `{ type: 'element', tagName: 'ol' | 'ul' }` 노드로 표현한다. 따라서 mdast를 hast로 변환해주는 *트랜스포머*가 필요한데, [`remark-rehype`](https://github.com/remarkjs/remark-rehype)가 바로 그 트랜스포머다.

<SideBySide caption='"> `Hello, world!`"의 mdast와 hast 표현'>

```js
{
  type: 'blockquote',
  children: [
    {
      type: 'paragraph',
      children: [
        {
          type: 'inlineCode',
          value: 'Hello, world!'
        }
      ]
    }
  ]
}
```

```js
{
  type: 'element',
  tagName: 'blockquote',
  children: [
    {
      type: 'element',
      tagName: 'p',
      children: [
        {
          type: 'element',
          tagName: 'code',
          children: [
            {
              type: 'text',
              value: 'Hello, world!'
            }
  // ...
```

</SideBySide>

# 트랜스포머 추가하기

```js
const processor = unified()
  .use(remarkParse) // Parser
  .use(remarkRehype) // mdast -> hast
  .use(rehypeStringify) // Compiler
  .process(file)
```

가장 기본적인 형태의 CommonMark-HTML 프로세서는 위와 같다. 나는 이미 생성된 AST를 바꿔야 하는 것이므로 새로운 트랜스포머를 정의해야 하고, 트랜스포머는 파서, 컴파일러와 마찬가지로 unified 플러그인이므로, unified 플러그인의 형태로 구현해야 한다.

## 플러그인 기본 형태

unified 트랜스포머 플러그인은 트리를 실제로 순회/조작하게 될 함수를 생성하는 팩토리 형태다.

```ts
import type { Root as HastRoot } from 'hast'
import type { Root as MdastRoot } from 'mdast'
import type { Plugin } from 'unified'

const transformer: Plugin<
  /* 플러그인 옵션 매개변수 */ void[],
  /* AST 루트 타입, hast 트랜스포머라면 HastRoot */ MdastRoot
> = () => {
  return (tree) => {
    // 트리 순회하면서 바꾸기
  }
}
```

반환하는 함수의 본문에서 트리를 순회하면 된다. 순회를 직접 구현할 수도 있지만, [unist와 unified](#unist와-unified)에 적었듯 AST의 종류가 달라도 형태가 같으면 동일한 작업을 할 수 있으므로, unist 트리라면 모두 사용할 수 있는 unified 유틸리티 패키지가 다수 존재한다. 그리고 그중에 [`unist-util-visit`](https://github.com/syntax-tree/unist-util-visit)이 깊이 우선 순회를 제공한다.

### 콜백 함수 구문

```ts
import { visit } from 'unist-util-visit'

visit(tree[, test], function callback(node, index, parent) {/* ... */}[, reverse])
```

- : `tree`
  - 트리의 루트 노드를 지정한다. 플러그인 반환 함수가 매개변수로 받는 `tree`를 그대로 넘겨주면 된다.
- : `test` (선택)
  - 필터를 지정한다. 이 필터를 통과해야 `callback`을 호출한다. [`unist-util-is`](https://github.com/syntax-tree/unist-util-is)의 [`is()`](https://github.com/syntax-tree/unist-util-is#isnode-test-index-parent-context) 함수가 받는 `test` 매개변수와 같은 타입의 값을 지정하면 된다. 문자열을 지정하면, `node.type === test`인 노드가 통과하는데, TypeScript 사용 시 `callback`의 `node` 타입이 해당 타입에 대응하는 인터페이스로 알아서 추론되므로 유용하다.
- : `callback`

  - 노드에 대한 콜백 함수를 지정한다.

    - : `node`
      - 순회 중인 노드.
    - : `index`
      - 노드가 부모의 자식 리스트에서 위치한 인덱스.
    - : `parent`
      - 노드의 부모 노드.

    노드를 통째로 갈아치워야 할 경우 `parent[index] = newNode`를 해도 문제가 없으며, (`callback`이 아무것도 반환하지 않을 경우) 정상적으로 `newNode`의 `children`에 대해 순회를 계속 진행한다. `parent.children`의 길이를 바꿀 수도 있다.

    반환하는 값에 따라 다음 동작이 달라지는데, 가능한 값은 다음과 같다.

    - : `true` 또는 `void` (`undefined`)
      - 순회를 계속 진행한다.
    - : `false`
      - 순회를 즉시 종료한다.
    - : `'skip'`
      - 이 노드의 자식, 또는 현재 노드를 교체한 경우 새로운 노드의 자식을 순회하지 않고, `parent`의 다음 자식으로 넘어간다.
    - : `number`
      - 이 노드의 자식, 또는 현재 노드를 교체한 경우 새로운 노드의 자식을 모두 순회한 후, `parent`의 다음 자식이 아니라 반환한 값의 인덱스에 위치한 자식을 순회한다. `parent.children`의 길이가 바뀌는 경우 유용하다.
    - : `['skip', number]`
      - 이 노드의 자식, 또는 현재 노드를 교체한 경우 새로운 노드의 자식을 순회하지 않고, `parent`의 다음 자식이 아니라 반환한 값의 인덱스에 위치한 자식을 순회한다. `parent.children`의 길이가 바뀌는 경우 유용하다.

## remark로 노트 박스 생성

mdast를 순회하면서 `node.type === blockquote`인 노드를 찾고, 인용문이 `[note]`, `[warn]`, `[fatal]`로 시작한다면 노트 박스로 변환하는 플러그인은 다음과 같다.

```ts
/*
찾아야 하는 노드 형태:
{
  type: 'blockquote',
  children: [
    {
      type: 'paragraph',
      children: [
        {
          type: 'text',
          value: '[note] 어쩌구 저쩌구'
        },
        // ...
      ]
    }
  ]
}
*/

import type { Paragraph, Parent, Root } from 'mdast'
import type { Plugin } from 'unified'

// CommonMark 노드에는 노트 박스를 나타내기에 적합한 노드 타입이 없으므로 하나 정의한다.
interface Notebox extends Parent {
  severity: 'note' | 'warn' | 'fatal'
  type: 'notebox'
}

const transformer: Plugin<void[], Root> = () => {
  return (tree) =>
    visit(tree, 'blockquote', (blockquote, index, parent) => {
      const [maybeParagraph] = blockquote.children
      // 블록 인용문 안의 텍스트는 문단(type: paragraph) 노드 안에 들어간다.
      if (maybeParagraph?.type !== 'paragraph') {
        return
      }

      const [maybeText] = (maybeParagraph as Paragraph).children
      // 문단 안에 텍스트 리터럴(type: text)이 들어가는 구조.
      if (maybeText?.type !== 'text') {
        return
      }

      // 텍스트 리터럴이 [note], [warn], [fatal] 중 하나로 시작하는지 확인.
      const severity = maybeText.value.match(/^\[(note|warn|fatal)\]/)?.[1] as 'note' | 'warn' | 'fatal' | undefined
      if (!severity) {
        return
      }

      // 텍스트 리터럴에서 [note], [warn], [fatal]을 제거.
      text.value = text.value.slice(severity.length + 2).trim()

      // 이 노드(블록 인용문)를 대체할 새로운 노드(노트 박스)를 선언.
      const noteboxNode: Notebox = {
        children: blockquote.children,
        severity,
        type: 'notebox',
      }

      // 부모의 자식들 중 이 노드를 대체한다.
      parent.children[index] = noteboxNode
    })
}

export { transformer as remarkNotebox }
```

### TypeScript

TypeScript를 사용하는 경우 `parent.children[index] = noteboxNode`에서 타입 오류가 발생한다. mdast에는 `{ severity: ..., type: 'notebox' }`인 타입이 없기 때문이다. 인식하도록 만드는 것은 어렵지 않다. 아래와 같이 `mdast` 모듈을 [증강](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation)하면 된다.

```ts
// mdast.d.ts
import type { Parent } from 'mdast'

declare module 'mdast' {
  // 플러그인 파일에 선언했던 Notebox 타입을 옮겨온다.
  export interface Notebox extends Parent {
    severity: 'note' | 'warn' | 'fatal'
    type: 'notebox'
  }

  // mdast에서 새로운 노드 유형을 추가할 때 사용할 수 있는 타입에는
  // - BlockContent, 블록 레벨 노드. CSS에서 "블록 레벨 요소"라고 부르던 것들과 동일한 개념이다. 문단, 헤딩, 리스트 루트, 블록 인용문 등 자식을 가질 수 있는 노드.
  // - PhrasingContent, 인라인 레벨 노드. 마찬가지로 CSS "인라인 요소"와 동일하다. 인라인 코드, 강조, 취소선 등 자식을 가질 수 없는 리터럴 노드.
  // - 등등.

  // 노트 박스는 자식을 포함하는 블록 레벨 노드여야 하므로 BlockContent를 증강해야 한다.
  // BlockContent의 정의는 다음과 같다.
  //   type BlockContent = BlockContentMap[keyof BlockContentMap]
  // 따라서 직접 BlockContent를 수정하지 않고, BlockContentMap에 { [type]: NewNodeType }의 형태로 추가한다.
  type BlockContentMap = {
    notebox: Notebox
  }
}
```

보통 모듈 증강은 타입이 어딘가 잘못됐거나, 아예 타입을 제공하지 않는 모듈에 대해서 가끔 작성하는 경우가 대부분이라 내키지 않을 수도 있지만, 이런 식의 증강도 자주 쓰인다. [`@types/mdast`](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/mdast/index.d.ts)에 적힌 주석의 내용을 참고.

## 노트 박스의 hast 노드 생성

```ts
const processor = unified()
  .use(remarkParse) // Parser
  .use(remarkNotebox) // mdast blockquote -> mdast notebox
  .use(remarkRehype) // mdast -> hast
  .use(rehypeStringify) // Compiler
  .process(file)
```

`Blockquote` 노드를 성공적으로 변환했다! 그런데 노트 박스는 HTML에 `div.notebox.notebox-${severity}`로 출력하고 싶은데, `remarkNotebox`의 코드 어디에도 `div` 세 글자는 보이지 않는다.

> mdast에서 hast로의 변환은 `remark-rehype`(`remarkRehype`)에서 일어나고, ...

그렇지만 `remark-rehype`는 `type: 'notebox'`인 mdast 노드의 존재도 모르고, 당연히 변환법도 모른다. 노트 박스를 hast로 변환하려면 `remark-rehype`에게도 처리 방법을 알려줘야 한다.

### 노트박스의 변환 방법을 알려주려면

`remark-rehype`가 CommonMark 노드를 어떻게 변환하는지 확인하면 도움이 된다. `remark-rehype`는 [내부적으로 `mdast-util-to-hast`의 `toHast()`를 사용](https://github.com/remarkjs/remark-rehype/blob/1e0c67d/lib/index.js#L56)한다. 이어서, [`mdast-util-to-hast`의 `toHast()`](https://github.com/syntax-tree/mdast-util-to-hast/blob/3d83958/lib/index.js#L220)에는 `one(h, tree, null)`이 보이고, 다시 이어서 [`one()`](https://github.com/syntax-tree/mdast-util-to-hast/blob/3d83958/lib/traverse.js)은 다음과 같은 코드로 정의된다.

```ts
function one(h, node, parent) {
  const type = node && node.type
  let fn
  // ...
  fn = h.handlers[type]
  // ...
  return fn(h, node, parent)
}
```

즉, `h.handlers`는 [mdast 노드의 `type`을 키로 하는 객체 맵](https://github.com/syntax-tree/mdast-util-to-hast/blob/3d83958/lib/handlers/index.js)이고, 그 값이 mdast 노드를 hast 노드로 변환하는 처리기 함수임을 알 수 있다. `toHast()` 본문으로 돌아가면 `h = factory(...)`고, `factory()` 본문을 보면 [`h.handlers`는 내장 처리기들과, 옵션의 `handlers`를 합친 것](https://github.com/syntax-tree/mdast-util-to-hast/blob/3d83958/lib/index.js#L130)이다.

[내장 처리기 함수 중 하나](https://github.com/syntax-tree/mdast-util-to-hast/blob/3d83958/lib/handlers/paragraph.js)를 보면 작성 방법도 알아낼 수 있는데, [`h`라는 함수 이름도 그렇고](https://github.com/hyperhype/hyperscript) 전형적인 렌더 함수의 모습이다.

```ts
export function paragraph(h, node) {
  // all()은 순회 함수
  return h(node, 'p', all(h, node))
  //    태그 이름 ^    ^
  //       자식 리스트 |
}
```

종합해보면, 노트 박스를 위한 처리기 함수는 이렇게 작성할 수 있다.

```js
const processor = unified()
  .use(remarkParse)
  .use(remarkNotebox)
  .use(remarkRehype, {
    // remark-rehype에 제공하는 옵션 중 handlers는 그대로 mdast-util-to-hast로 전달된다.
    handlers: {
      // 세 번째에 '프롭'을 지정할 경우 자식 노드 리스트는 네 번째 매개변수.
      // type: 'notebox'로 선언했으므로 키를 notebox으로 함.
      notebox: (h, node) => h(node, 'div', { className: `notebox notebox-${node.severity}` }, all(h, node)),
    },
  })
  .use(rehypeStringify)
  .process(file)
```

<SideBySide caption="Markdown 노트 박스와 컴파일 결과">

```md
> [note] 참고 등급 노트 박스

> [warn] 경고 등급 노트 박스
```

```html
<div class="notebox notebox-note">
  <p>참고 등급 노트 박스</p>
</div>
<div class="notebox notebox-warn">
  <p>경고 등급 노트 박스</p>
</div>
```

</SideBySide>

---

unified 생태계는 입력 값이 바로 결과 값으로 나타나는 것이 아니라 AST를 거쳐 가기에 기존엔 불가능했던 방법으로 접근할 수 있다. remark를 쓰지 않았다면, 완전히 새로운 구문을 추가하려는 것이 아닌데도 [파싱과 컴파일링 과정에 직접 관여해야](https://github.com/markdown-it/markdown-it/blob/1cd8a51/lib/rules_block/list.js#L192-L200) 할 수 있었다. 하지만 파서와 컴파일러는 완벽히 캡슐화되어있어 신경 쓰지 않을 수 있었다. 그저 이론에 불과했던 AST를 직접 접해보는 것과, 계속 벼르고 있었지만 해결할 길을 알지 못했던 기능의 구현을 같이 해내서 재밌었다.

unified는 프로그래밍 언어 외에 (공백이 중요하므로 AST가 아니라 CST를 사용하는) [자연어 파서와 컴파일러](https://github.com/retextjs/retext)도 가지고 있다. [부적절한 단어 경고](https://alexjs.com/)와 [단조로운 문장 피하기](https://wooorm.com/write-music/)에 썼다고 한다.
