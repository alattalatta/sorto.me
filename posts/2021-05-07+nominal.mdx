---
title: "TypeScript: 타입 시스템으로 원시 값을 구분하기"
description: 주소와 전화번호, 원화와 달러—TypeScript에서 명목적 타입을 흉내내기
excerpt: 주소와 전화번호, 원화와 달러
image: /images/2021-05-07/nominal.png
---

타입 시스템은 프로그램을 돌려보지 않고도 개발 과정에서 프로그램의 유효성을 판단할 수 있는 방법이다. 숫자를 바라는 곳에 함수를 넣으면 안된다거나. 그러면 전화번호에 주소를 넣어버린 상황 역시 돌려보지 않고도 알 수 있을까?

# 명목적과 구조적

명목적(Nominal)과 구조적(Structural) 시스템은 타입 시스템을 구분하는 큰 방법 중 하나이다.

```ts
type Address = string
type Tel = string

const address = '010-1111-2222' as Tel
```

TypeScript에서 위의 코드는 유효하다. `Address`와 `Tel`은 이름이 다르지만, 문자열이라는 "구조"(형태)가 동일하기 때문이다. 구조에 대해 더 쉽게 보려면 인터페이스의 예시를 보면 된다.

```ts
interface Foo { a: number }
interface Bar { a: number, b: string }

const foo: Foo = { a: 3, b: 'b' } as Bar
```

이 코드 역시 `Foo`에 `Bar`를 할당하고 있지만 유효하다. 심지어 `Bar`에는 추가 문자열 속성 `b`가 존재하는데도. 이는 `Foo`가 되기 위해 필요한 `a: number`를 `Bar`도 만족하기 때문이다. `Foo`는 `b`에 대해 알지 못하므로, 아무것도 질문하지 않는다.

이렇게, 서로 상속같은 관계가 없는데도 구조만 같으면 동일한 타입으로 취급하는 시스템을 **구조적 타입 시스템**(Structual type system)이라고 말한다. 반면, 타입의 **이름**만 달라도 별개의 타입으로 취급하면 **명목적 타입 시스템**(Nominal type system)이라고 부른다. ReScript와 같은 언어에서는 (Polymorphic Variant 제외) 명목적 타입을 채택하고 있으므로 같은 문자열 타입이라도 서로 호환되지 않는다.

하나의 언어에서 두 가지 시스템을 모두 사용할 수도 있다. Flow의 경우 클래스에 한정해서 명목적 타입을 사용한다.

```ts
/* @flow */
class Foo { a: number }
class Bar { a: number }

// TS에서는 오류 아님
const foo: Foo = new Bar() // Cannot assign `new B()` to `a` because `B` is incompatible with `A`.
```

그리고 두 가지 시스템 중 어느 하나가 우월하거나 열등한 것도 아니다. 그러나, 정말로 주소 문자열에는 전화번호 문자열 말고 주소 문자열만 넣을 수 있도록 하려면, 구조적 타입 시스템의 TypeScript에서는 어떻게 해야 할까?

# 정석: 객체와 구분용 속성

"정석"적인 방법으로는 [Discriminated Union](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions)(구별된 구조체?)을 들 수 있겠다. "구별된 구조체"는 두 개의 객체 타입을 묶은 타입(`A | B`)인데, 각각의 타입에는 서로에게 없는 고유한 속성 값을 마련해두는 것이다.

```ts
type Circle = {
  size: number
  kind: 'circle'
}
type Square = {
  size: number
  kind: 'square'
}
type Shape = Circle | Square
```

위의 타입을 가정할 때, 임의의 `Shape`가 `Circle`인지 `Square`인지 알아내는 것은 `shape.kind === 'circle'`만으로 구분 가능하다. `'circle'`인 경우는 `Circle`밖에 없고, `Circle`이 아니면 `Square`니까, 저 "크기"가 원의 크기인지 사각형의 크기인지 역시 빌드 타임에 구분할 수 있는 것.

그렇다면 우리의 문제도 동일하게 해결할 수 있다. 인터페이스보다 짧은 길이로 정의할 수 있는 튜플을 활용해보자.

```ts
type Unique<Kind extends string, Value> = readonly [Kind, Value]

type Address = Unique<'Address', string>
type Tel = Unique<'Tel', string>

const asAddress = (value: string): Address => ['Address', value]
const asPhone = (value: string): Tel => ['Tel', value]

const nationalAssemblyAddr = asAddress('서울특별시 영등포구 여의도동 의사당대로 1')
const nationalAssemblyTel = asTel('02-788-2114')
```

이제 주소와 전화번호를 헷갈리고 싶어도 헷갈릴 수 없게 됐다?

그러나... 이제 원시 문자열을 튜플/객체로 만드는 런타임 코드(`asAddress()`, `asPhone()`)가 필요해졌고, 데이터 역시 원시 문자열이 아닌 완전히 다른 존재가 됐다. 타입 시스템 안에서만 해결할 수도 있을까?

# 낙인 찍기

타입 브랜딩(branding, 낙인)은 알게 모르게 자주 쓰이는 기법으로, 원시 값에 객체를 "낙인" 찍어서 일반적으로 생성할 수 없는 타입을 선언한다. 우연히 생성할 수 없으므로 구조적으로 동일해지는 일이 없고, 따라서 고유한 타입을 흉내낼 수 있는 방식.

```ts
type Brand<Key extends string, Value> = Value & { __brand: Key } // 키 이름은 아무거나 가능

type Address = Brand<'Address', string>
type Tel = Brand<'Tel', string>

const nationalAssemblyAddr = '서울특별시 영등포구 여의도동 의사당대로 1' as Address
const nationalAssemblyTel = '02-788-2114' as Tel

let wrongAssignment: Tel = nationalAssemblyAddress as Tel
//                                                 ^^^^^^^ Error
```

`as`의 사용에서 다소 취약해보일 수도 있으나, 마지막 줄처럼 하면 두 개의 브랜딩 타입을 캐스팅 하면 오류가 발생한다. 또한 브랜딩은 런타임 코드의 변화가 없으므로, 서버 응답을 처음부터 브랜딩한 타입으로 지정할 수 있어 편리하기도 하다. (유효성 검증은 따로 수행)

```ts
type ProductID = Brand<'ProductID', number>
type KRW = Brand<'KRW', number>

type Product = {
  id: ProductID
  name: string
  price: KRW
}

declare const getProduct = (id: ProductID) => Product
declare const deleteProduct = (id: ProductID) => void

const product = getProduct(31 as ProductID)
deleteProduct(product.price) // Error!
```

## 한계

하지만 명목적 타이핑의 흉내만 내는 것이라서, 원본 원시 값에 할당하면 무조건 성립한다.

```ts
declare const addr: Address

const str: string = address // OK?
```

그리고 기존 원시 값을 바라는 연산이나 함수를 사용할 수는 있지만, 그 결과는 무조건 원시 값으로 나타나므로 래핑 함수를 추가로 생성해줘야 원활하게 개발할 수 있다. 꽤 귀찮은 일.

```ts
function addKRW(a: KRW, b: KRW): KRW {
  return a + b as KRW
}

function maxKRW(...values): KRW {
  return Math.max(...values) as KRW
}
```

그런데 리팩터링(2판)에서는 이렇게 작은 함수로 캡슐화하는 것을 추구하던데, 오히려 좋은 습관을 강제하는 걸까? 사용할 연산을 모두 새롭게 정의해줘야 한다는 것이 너무너무 귀찮아서 피해왔던 건 아닐지 반성하기...

---

구조적 타입 시스템도 장점이 있다. 명시적인 관계 지정을 하지 않아도 되므로 덜 번거롭고, 서로 다른 라이브러리의 타입을 호환해서 사용할 수 있는 것도 구조 비교만 하기 때문이므로 JavaScript와 그 생태계에서는 좋은 선택이라고 생각한다. 하지만 가끔은 또 다른 안전 레이어가 있으면 좋겠다 싶을 때도 있는데, 그럴 땐 중요한 값에 한정해서 낙인을 찍어보면 어떨까?

고도로 발달된 타입 시스템 활용과, 런타임 코드가 있으나 차이가 너무 작아서 원시 연산과 비교하는 의미가 없는 성능의, 현 상황에서 제일 뛰어난 명목 타이핑 시뮬레이션이라고 평가받는 라이브러리도 있다. [`newtype-ts`](https://github.com/gcanti/newtype-ts)으로, `fp-ts` 생태계의 일원이라서 `Option`처럼 불확실한 값 모델링도 처음부터 지원하니까 정말 제대로 해보고 싶으면 한번 해봐도 괜찮겠다. 저 생태계가 모두 그렇듯 사용법도 어렵고 문서도 어려운 것이 제일 큰 단점.
