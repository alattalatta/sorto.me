---
title: "Page Object Model, POM"
description: E2E 테스트 케이스를 보기 좋게 만들기
excerpt: E2E 테스트 케이스를 보기 좋게 만들기
---

테스트는 중요하다. 이건 누구나 알고 있을 것이고, 컴포넌트도 예외는 아니다. 그러니 통합 테스트 역시 중요하다. 그러나 통합 테스트는 어렵다. "테스트 코드는 누가 테스트하냐" 이전에, 테스트의 범위부터 이미 고민의 시작이다.

*디자인 시스템*처럼 변화가 적고 경계가 뚜렷한 *컴포넌트 라이브러리*의 경우에는 문제가 덜 하다고 생각한다. 그런데 서비스를 운영하는 입장에서는, 어디까지 테스트를 해야 잘하는 걸까? 확실한 테스트를 지향해서 모든 컴포넌트의 상당량을 다 확인한다면, 비즈니스 요구사항에 따른 변경점이 생길 때 테스트 케이스 역시 저 아래부터 아주 위쪽까지 모두 다 바꿔줘야 한다. 케이스를 늘려가면 늘려갈수록 이게 정말 서비스를 위한 테스트인지, React를 위한 테스트인지, 테스트를 위한 테스트인지 분간하기 힘들어진다. 그렇다고 느슨하게 풀어버리면, 확인하는 부분이 너무 적어져 굳이 테스트를 유지하는 의미가 흐릿해진다.

결국 종착지는 E2E 테스트였다. 지금까지 많은 서비스를 만져본 건 아니지만 얻을 수 있는 것이 명백하니 결론도 그렇게 되더라. 실제로 브라우저에서 구동하는 것이니 바깥 환경 목업처럼 크고 곤란한 것을 일일이 신경 쓰지 않아도 되고, 스크롤처럼 (통합) 테스트 케이스에서 표현하기 힘든 것도, 그냥 _스크롤_ 하면 되니까.

그러나 E2E 테스트는 가장 큰 범위를 다루다보니 케이스 작성 과정도 지옥에 가깝다. A 요소가 나타나길 기다리다가 B 요소를 클릭하고, API 응답을 대기한 후 C 요소가 올바른 형태인지 판별하고... 이걸 테스트 케이스 안에 집어넣고 있다보면 정신이 아득해진다.

```ts
test('...', async () => {
  await page.waitForSelector(q`contents`)
  await page.click(q`load-more`)

  const response = await (await page.waitForResponse('**/api/list*')).json()

  const list = await page.waitForSelector(q`list`)
  const view = Promise.all(
    (await list.$$(q`item`)).map(async (el) => {
      const title = await el.evaluate((el) => el.querySelector(q`title`)?.textContent)
      const quantity = await el.evaluate((el) => el.querySelector(q`quantity`)?.textContent)

      return { title, quantity }
    })
  )
  // !!!

  expect(response).toEqual(view)
})
```

작성 시점부터 이미 아득함을 느끼게 되면 나중엔 손조차 댈 수 없게 된다는 뜻이니 심각하다. 결국 E2E는, 내가 테스트를 시도했다는 사실만 남기고, 아무것도 아닌 존재가 되기 십상이다.

# Page Object Model

이전 E2E 과제에서는 [`jest-puppeteer`](https://github.com/smooth-code/jest-puppeteer)를 사용했다. 이번에는 주변 추천 및 Safari(Webkit) 테스트를 위해 [Playwright](https://playwright.dev/)를 사용했다. API가 Puppeteer와 거의 같긴 했지만 일단 처음 써보는 것이고, 무엇보다 Puppeteer와 달리 자체 테스트 러너 등 E2E 테스트에 더 무게를 실은 것으로 보였으므로, 위의 문제를 해결할 방법도 찾을 겸 문서를 살펴봤으니 시선이 향한 곳이 [Page Object Model](https://playwright.dev/docs/pom)이었다.

<Callout.Root
  childAs="div"
  label={
    <Callout.Cite href="https://playwright.dev/docs/pom">
      Page Object Models
    </Callout.Cite>
  }
>

Large test suites can be structured to optimize ease of authoring and maintenance. Page object models are one such approach to structure your test suite.

A page object represents a part of your web application. An e-commerce web application might have a home page, a listings page and a checkout page. Each of them can be represented by page object models.

Page objects simplify authoring. They create a higher-level API which suits your application.

Page objects simplify maintenance. They capture element selectors in one place and create reusable code to avoid repetition.

</Callout.Root>

POM을 검색했을 때, 대부분의 결과가 Selenium 예제로 향하는 것을 보아 POM이라는 용어 자체는 이미 E2E의 세계에는 널리 퍼진 패턴으로 보인다. Java도, Selenium도 해본 적이 없으니 관련해선 말을 줄이고, 이제 개념을 처음 접한 초심자로서 POM과 같은 패턴의 필요성을 정리해보면,

1. 재사용성. 굳이 설명하지 않아도 될 것 같다.
1. 책임의 분리. 테스트 케이스에서 중요한 것은 테스트 그 자체고, 페이지의 동작과 모양새는 어디까지나 구현 상세에 불과하다. 페이지의 모양/기능이 달라졌을 때 테스트 케이스의 이곳저곳 산재한 선택자 등등을 고쳐야 한다면, 그건 이론적으로는 모두들 알고 있는 안티 패턴이다.

이 두 가지로 말미암아 (인용문에 나와있듯) 테스트 작성과 유지보수 측면을 개선할 수 있다는 것. 즉, POM은 페이지의 동작과 상세를 표현하는 독립된 객체 모델이다.

```ts
class FooPage {
  constructor(private readonly page: Page) { }

  navigate(): Promise<Response> {
    return this.page.navigate('/foo/bar')
  }

  name(): Promise<string> {
    return this.page.waitForSelector(q`name`).then((el) => el.textContent)
  }

  descriptions(): Promise<string[]> {
    return this.page.waitForSelector(q`descriptions`).then((el) => el.textContent.split('\n'))
  }
}
```

## 책임의 분리

처음 패턴을 도입할 때 고민했던 것 중 하나는 어서션까지 POM에서 처리하도록 만들지의 여부였다.

```ts variant=bad
import { test, expect } from '@playwright/test'
import { POM } from './POM'

class Search extends POM {
  title(): Promise<string> {
    return this.page.waitForSelector(q`title`).then((el) => el.textContent)
  }

  async assertTitle(): Promise<void> {
    expect(await this.title()).toBe('검색')
  }
}

test('...', async ({ page }) => {
  const pom = new Search(page)
  await pom.navigate()
  await pom.assertTitle()
})
```

그러나 책임의 분리를 통해 경계를 명확하게 그리고자 하는 것이 중요 목표니, POM은 항상 페이지 동작에만 집중해야 한다. 항상 클래스가 비대해지는 것을 경계하자.

```ts variant=good
import { test, expect } from '@playwright/test'
import { POM } from './POM'

class Search extends POM {
  title(): Promise<string> {
    return this.page.waitForSelector(q`title`).then((el) => el.textContent)
  }
}

test('...', async ({ page }) => {
  const pom = new Search(page)
  await pom.navigate()
  const title = await pom.title()
  expect(title).toBe('검색')
})
```

## 메서드 책임 분리

유지보수의 용이함을 위해선 메서드 하나가 페이지의 기능 하나에만 대응해야 할 필요가 있다. POM을 논하기 이전에 기본 원칙의 문제로, "검색 제출 후 응답 대기 후 결과 리스트 반환"은 너무 많은 것을 한 번에 처리한다.

다만 이 부분에서도 고민한, 그리고 아직 고민 중인 것은 사용자의 입력에 대응하는 네트워크 응답의 대기를 어디서 맡냐는 점이다. 지금은 한 메서드에서 처리하려고 하는데, 사용자의 행동으로 인해 API 요청이 발생한다면 응답 대기시간까지도 기능의 일부라고 봐야 하지 않을까? 별도의 '응답 대기' 메서드를 분리하는 것은 이후 코드 변경에 있어 너무 취약해진다. 실수로 빠트리거나, 존재하지 않는 응답을 대기하게 되거나...

```ts
class Search extends POM {
  search(query: string): Promise<Response> {
    await this.page.fill(q`search`, query)
    await this.page.click(q`submit`)
    return this.page.waitForResponse('**/api/list*')
  }

  searchResult(): Promise<{ title: string, description: string }> {
    const elements = await this.page.$$(q`result-item`)
    return elements.map(/* ... */)
  }
}

test('...', async ({ page }) => {
  const page = new Search(page)
  await pom.navigate()

  const response = await (await page.search('햇반')).json()
  const searchResult = await page.searchResult()

  expect(searchResult).toEqual(response)
})
```

## 패턴은 도구를 몰라

POM을 Playwright 문서에서 접했고, Playwright으로 작성했지만, 검색결과의 Selenium 비중이 말하듯 이건 어디까지나 테스트와 페이지 동작의 분리를 위한 패턴이라 사용 중인 브라우저 자동화 도구에 상관하지 않는다.

# 마무리

제일 재미없고, 제일 난잡해지기 쉬운 코드가 테스트 케이스 코드인데, 정말 필요한 부분만 빼면 모두 덜어낼 수 있다는 점 하나로도 장족의 발전이다. 그런데 사실, 비즈니스 코드에서는 이미 책임의 분리를 위해 기를 쓰고 있는데 왜 테스트 케이스에서는 같은 생각을 못했을까? 테스트에 관여하는 파일을 늘리기 싫은 것도 있었겠지만, 테스트 코드는 크게 고민하지 않고 절차적으로 접근하고 있었다. 같은 테스트라고는 하지만, E2E 테스트와 단위 테스트는 생각의 방향을 달리 해야 하지 않았을까.

지금까지 버려진 E2E 테스트 케이스에게 사과합니다. 앞으로는 덜 버릴 수 있기를 기원한다.
